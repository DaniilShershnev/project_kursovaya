Для простоты написания используем ООП на питон. Основной класс - FunctionPlotter . От него строим детей и их методы. 


В проекте используем именно numpy массив, потому что он написан на C и Fortran,что намного быстрее явной работы через язык питон с массивами(а на самом деле списками), которые все создают через []. 
Немного теории:
	1. Массив в питон - это массив, элементы которого являются указателями на элементы в памяти. В памяти по указателям лежат сами объекты. 
	2. Массив через numpy: хранится в памяти линейно. Для моей системы: 40Gb оперативной памяти это вообще не проблема. Относительно массива в питоне это дает существенный плюс: используется намного меньше памяти, благодаря чему, можно будет строить очень точные графики, загружая большое количество точек. Приведем пример, показывающий насколько меньше памяти используется при создании массива через numpy:
	Хотим создать массив из 3 чисел типа float. Каждое число типа float весит 28 байт. 
		-Штатный метод []: храним три указателя по 8 байт каждый на каждую ячейку памяти - это 24 байта. 
			┌─────────────────────────┐
			│ ob_refcnt: 2            │  	    	8 байт - счетчик ссылок (для garbage collector)
			│ ob_type: <type 'float'> │  	   	8 байт - указатель на тип объекта
			│ ob_fval: 3.14           │  	   	8 байт - само число (double)
			│ padding                 │  		4 байта - выравнивание памяти
			└─────────────────────────┘
		-Используем numpy: храним только сами числа: 8байта*3 = 24 байта
	Понятно, что надо использовать numpy

Помимо этого, у най numpy есть быстрые функции, которые написаны на C и Fortran, как было упомянуто ранее. Это позволяет оптимизировать программу.




Какие классы есть в проекте, для чего нужны, какие у них функции и для чего они нужны:
GraphPlotter (базовый класс):
    Наследники:
	1. FunctionPlotter
    Функции:
	1. __init__ - создает figure и axes
		- принимает ничего
		- возвращает ничего
		- нужна для инициализации, создает self.fig (Figure), self.ax (Axes), self.curves (list)
	2. set_axes - настраивает пределы и подписи осей
		- принимает set_axes(self, xlim, ylim, xlabel, ylabel, grid)
			- xlim: list[float, float] или None - пределы по x
			- ylim: list[float, float] или None - пределы по y
			- xlabel: str - подпись оси x
			- ylabel: str - подпись оси y
			- grid: bool - включить сетку
		- возвращает ничего 
		-Нужна для 
	3. add_curve - добавление линию на график
		- принимает add_curve(self, x, y, style)
			-x: numpy.ndarray - массив координат x
			-y: numpy.ndarray - массив координат y
			-style: dict - стиль линии
		- возвращает ничего 
		-нужна для создания matplotlib.lines.Line2D Объекта 
	4. save - экспортирт в SVG
		-принимает filename: str - путь к файлу SVG
		- возвращает ничего
		- нужна для сохранения файла 
	5. clear - очищение графика
		- принимает ничего 
		- возвращает ничего 
		- нужна для очистки self.ax и self.curves
FunctionPlotter
    Наследники: нет
    Функции
	1. __init__ - инициализирует plotter с глобальными параметрами
		- принимает init(self, global_params)
		- возвращает ничего 
		- вызывает функцию GraphPlotter.init(), сохраняет self.global_params
	2. add_curve_from_latex - строит кривую из LaTeX формулы
		- принимает add_curve_from_latex(self, formula_latex, params, x_range, style)
			- formula_latex: str - формула в формате LaTeX
			- params: dict - параметры для формулы (локальные)
			- x_range: list[float, float] - диапазон значений x
			- style: dict - стиль линии
		- возвращает ничего 
		- создает numpy массивы x и y 
SymPyFunction
    Наследники: нет
    Функции 
	1. __init__ - парсит LaTeX формулу в sympy дерево
		- принимает init(self, formula_latex)
			- formula_latex: str - формула в формате LaTeX
		- возвращает ничего 
		- созает  self.expr (sympy.Expr), self.symbols (list), self.func_compiled (None)
	2. compile - компилирует в numpy функцию
		- принимает compile(self, symbol_order) 
			- принимает symbol_order: list[sympy.Symbol] - порядок символов для функции
		- возвращает funstion - скомпилированнуюnumpy функцию
		- создает self.func_copiled
	3. evaluate - вычисляет значения функции
		- принимает evaluate(self, kwargs)
			- kwargs: dict - значения переменных {имя: значение}
		- возвращает numpy.ndarray или float - результат вычисления 
Вспомогательные функции:
I.validators.py:
	1. validate_config - проверка корректности конфигурации
		- принимает cofig.dict- конигурация графика
		- возвращает bool переменную
		- выдает ValudeError если ошибка
	2. merge_params - объединение глобальных и локальных параметров

Теперь несколько слов про некоторые файлы проект
I."D:\graphic\test_simple.py"
 Строки 1-3:
	import sys 
	import os
	sys.path.insert(0, os.path.dirname(os.path.abspath(__file__)))
Первая строка нужна для того, чтобы питон мог управлять путями импорта, вторая строка импортирет os, который позволяет работать с путями в windows, третью строчку разберем пошагово:
	1. __fie__ - путь к test_simple.py
	2.os.path.abspath(__file__) - абсолютный путь (D:\graphic\test_simple.py)
	3.os.path.dirname(...) - директория (D:\graphic)
	4.sys.path.insert(0, ...) - добавляет D:\graphic в список путей поиска модулей
	5.sys.path - список директорий, где Python ищет модули при импорте
Это нужно для того, чтобы питон мог корректно находить модули core, utils. Лучше не задаать четкий путь, потому что проект может немного видоизменятся, а четкое указание путей усложняет добавление новых функций в проект. 








