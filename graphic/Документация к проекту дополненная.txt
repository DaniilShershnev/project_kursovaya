Для простоты написания используем ООП на питон. Основной класс - GraphPlotter. От него строим детей и их методы.


В проекте используем именно numpy массив, потому что он написан на C и Fortran, что намного быстрее явной работы через язык питон с массивами(а на самом деле списками), которые все создают через [].
Немного теории:
	1. Массив в питон - это массив, элементы которого являются указателями на элементы в памяти. В памяти по указателям лежат сами объекты.
	2. Массив через numpy: хранится в памяти линейно. Для моей системы: 40Gb оперативной памяти это вообще не проблема. Относительно массива в питоне это дает существенный плюс: используется намного меньше памяти, благодаря чему, можно будет строить очень точные графики, загружая большое количество точек. Приведем пример, показывающий насколько меньше памяти используется при создании массива через numpy:
	Хотим создать массив из 3 чисел типа float. Каждое число типа float весит 28 байт.
		-Штатный метод []: храним три указателя по 8 байт каждый на каждую ячейку памяти - это 24 байта.
			┌─────────────────────────┐
			│ ob_refcnt: 2                    │  	    	8 байт - счетчик ссылок (для garbage collector)
			│ ob_type: <type 'float'>         │  	   	8 байт - указатель на тип объекта
			│ ob_fval: 3.14                   │  	   	8 байт - само число (double)
			│ padding                         │  		4 байта - выравнивание памяти
			└─────────────────────────┘
		-Используем numpy: храним только сами числа: 8байта*3 = 24 байта
	Понятно, что надо использовать numpy

Помимо этого, у numpy есть быстрые функции, которые написаны на C и Fortran, как было упомянуто ранее. Это позволяет оптимизировать программу.




Какие классы есть в проекте, для чего нужны, какие у них функции и для чего они нужны:

GraphPlotter (базовый класс):
    Наследники:		
	1. FunctionPlotter
	2. ODEPlotter
    Функции:
	1. __init__ - создает figure и axes
		- принимает ничего
		- возвращает ничего
		- нужна для инициализации, создает self.fig (Figure), self.ax (Axes), self.curves (list)
	2. set_axes - настраивает пределы и подписи осей
		- принимает set_axes(self, xlim, ylim, xlabel, ylabel, grid, equal_aspect, spines, grid_style, xticks, yticks)
			- xlim: list[float, float] или None - пределы по x
			- ylim: list[float, float] или None - пределы по y
			- xlabel: str - подпись оси x
			- ylabel: str - подпись оси y
			- grid: bool - включить сетку
			- equal_aspect: bool - одинаковый масштаб осей
			- spines: dict или None - настройка границ {'top': bool, 'right': bool, 'bottom': bool, 'left': bool}
			- grid_style: dict или None - стиль сетки (параметры для ax.grid())
			- xticks: list или None - деления на оси x
			- yticks: list или None - деления на оси y
		- возвращает ничего
		- нужна для настройки внешнего вида осей координат
	3. add_curve - добавление линии на график
		- принимает add_curve(self, x, y, style)
			- x: numpy.ndarray - массив координат x
			- y: numpy.ndarray - массив координат y
			- style: dict - стиль линии
		- возвращает ничего
		- нужна для создания matplotlib.lines.Line2D объекта
	4. save - экспортирует в SVG
		- принимает filename: str - путь к файлу SVG
		- возвращает ничего
		- нужна для сохранения файла
	5. clear - очищение графика
		- принимает ничего
		- возвращает ничего
		- нужна для очистки self.ax и self.curves

FunctionPlotter (наследник GraphPlotter):
    Наследники: нет
    Функции:
	1. __init__ - инициализирует plotter с глобальными параметрами
		- принимает __init__(self, global_params)
			- global_params: dict - глобальные параметры из params_global.py
		- возвращает ничего
		- вызывает функцию GraphPlotter.__init__(), сохраняет self.global_params
	2. add_curve_from_latex - строит кривую из LaTeX формулы
		- принимает add_curve_from_latex(self, formula_latex, params, x_range, style)
			- formula_latex: str - формула в формате LaTeX
			- params: dict - параметры для формулы (локальные)
			- x_range: list[float, float] - диапазон значений x
			- style: dict - стиль линии
		- возвращает ничего
		- создает numpy массивы x и y, вызывает add_curve для добавления на график

ODEPlotter (наследник GraphPlotter):
    Наследники: нет
    Функции:
	1. __init__ - инициализирует plotter с глобальными параметрами
		- принимает __init__(self, global_params)
			- global_params: dict - глобальные параметры из params_global.py
		- возвращает ничего
		- вызывает GraphPlotter.__init__(), сохраняет self.global_params
	2. solve_and_plot_time - решает ОДУ и строит зависимости от времени
		- принимает solve_and_plot_time(self, equations_latex, variable_names, initial_conditions, params, t_span, style_list)
			- equations_latex: list[str] - список уравнений в формате LaTeX
			- variable_names: list[str] - имена переменных системы
			- initial_conditions: list[float] - начальные условия
			- params: dict - локальные параметры
			- t_span: list[float, float] - временной интервал [t_start, t_end]
			- style_list: list[dict] - список стилей для каждой переменной
		- возвращает ничего
		- использует scipy.integrate.solve_ivp с методом DOP853 для решения системы ОДУ
	3. solve_and_plot_phase - решает ОДУ и строит фазовый портрет
		- принимает solve_and_plot_phase(self, equations_latex, variable_names, initial_conditions, params, t_span, var_indices, style)
			- equations_latex: list[str] - список уравнений в формате LaTeX
			- variable_names: list[str] - имена переменных системы
			- initial_conditions: list[float] - начальные условия
			- params: dict - локальные параметры
			- t_span: list[float, float] - временной интервал
			- var_indices: list[int, int] - индексы переменных для осей [x_var_index, y_var_index]
			- style: dict - стиль линии траектории
		- возвращает ничего
		- строит траекторию в фазовом пространстве (одна переменная против другой)
	4. add_vector_field - добавляет векторное поле на фазовый портрет
		- принимает add_vector_field(self, equations_latex, variable_names, params, var_indices, field_config)
			- equations_latex: list[str] - список уравнений в формате LaTeX
			- variable_names: list[str] - имена переменных системы
			- params: dict - локальные параметры
			- var_indices: list[int, int] - индексы переменных для осей
			- field_config: dict - конфигурация векторного поля
				- density: int - плотность сетки векторов
				- color: str - цвет стрелок
				- alpha: float - прозрачность стрелок
				- scale: float - масштаб стрелок
				- width: float - толщина стрелок
		- возвращает ничего
		- создает сетку точек в пределах осей, вычисляет производные в каждой точке, нормализует векторы и отображает их

SymPyFunction:
    Наследники: нет
    Функции:
	1. __init__ - парсит LaTeX формулу в sympy дерево
		- принимает __init__(self, formula_latex)
			- formula_latex: str - формула в формате LaTeX
		- возвращает ничего
		- создает self.expr (sympy.Expr), self.symbols (list), self.func_compiled (None)
	2. compile - компилирует в numpy функцию
		- принимает compile(self, symbol_order)
			- symbol_order: list[sympy.Symbol] - порядок символов для функции
		- возвращает function - скомпилированную numpy функцию
		- создает self.func_compiled с помощью sympy.lambdify
	3. evaluate - вычисляет значения функции
		- принимает evaluate(self, **kwargs)
			- **kwargs: dict - значения переменных {имя: значение}
		- возвращает numpy.ndarray или float - результат вычисления
		- если функция не скомпилирована, компилирует её автоматически

ODESystem:
    Наследники: нет
    Функции:
	1. __init__ - парсит систему ОДУ из LaTeX
		- принимает __init__(self, equations_latex, variable_names)
			- equations_latex: list[str] - список правых частей уравнений в LaTeX
			- variable_names: list[str] - имена переменных (например, ['x', 'y'])
		- возвращает ничего
		- создает self.equations (список sympy выражений), self.variables (список sympy символов), self.params (параметры системы), self.func_compiled (None)
		- автоматически определяет параметры: все символы, которые не являются переменными и не являются 't'
	2. compile - компилирует систему с подставленными параметрами
		- принимает compile(self, param_values)
			- param_values: list[float] - значения параметров в порядке self.params
		- возвращает function - скомпилированную функцию для solve_ivp
		- подставляет численные значения параметров в уравнения, компилирует через sympy.lambdify
	3. right_hand_side - вычисляет правую часть системы ОДУ
		- принимает right_hand_side(self, t, y, param_values)
			- t: float - текущее время
			- y: numpy.ndarray - текущее состояние системы (значения переменных)
			- param_values: list[float] - значения параметров
		- возвращает numpy.ndarray - производные всех переменных
		- если система не скомпилирована, компилирует автоматически


Вспомогательные функции:

I. validators.py:
	1. validate_config - проверка корректности конфигурации
		- принимает config: dict - конфигурация графика
		- возвращает bool (True если валидна)
		- выдает ValueError если ошибка
		- проверяет наличие обязательных полей: 'type', 'curves', 'output'
		- проверяет тип графика: 'function', 'ode_time', 'phase_portrait'
		- для function проверяет наличие 'formula', 'x_range', 'style'
		- для ode_time/phase_portrait проверяет 'equations', 'variable_names', 'initial_conditions', 't_span'
	2. merge_params - объединение глобальных и локальных параметров
		- принимает merge_params(global_params, local_params)
			- global_params: dict - глобальные параметры
			- local_params: dict - локальные параметры (могут быть None)
		- возвращает dict - объединенный словарь параметров
		- локальные параметры имеют приоритет над глобальными (перезаписывают их)

II. config_loader.py:
	1. load_config - загрузка YAML конфигурации
		- принимает config_path: str - путь к YAML файлу
		- возвращает dict - загруженная конфигурация
		- использует yaml.safe_load для безопасной загрузки
	2. load_batch_configs - загрузка пакета конфигураций
		- принимает batch_path: str - путь к YAML файлу с пакетом
		- возвращает list[dict] - список конфигураций
		- загружает основной файл, затем загружает все указанные в нём конфигурации


Главные функции в main.py:

	1. plot_from_config - главная функция маршрутизации
		- принимает config: dict - конфигурация графика
		- возвращает ничего
		- вызывает validate_config, затем направляет в нужную функцию в зависимости от типа
	2. plot_function - построение графика функции
		- принимает config: dict - конфигурация типа 'function'
		- возвращает ничего
		- создает FunctionPlotter, добавляет все кривые из конфигурации, настраивает оси, сохраняет в SVG
	3. plot_ode_time - построение временных зависимостей ОДУ
		- принимает config: dict - конфигурация типа 'ode_time'
		- возвращает ничего
		- создает ODEPlotter, решает систему и строит зависимости переменных от времени
	4. plot_phase_portrait - построение фазового портрета
		- принимает config: dict - конфигурация типа 'phase_portrait'
		- возвращает ничего
		- создает ODEPlotter, строит векторное поле (если включено), строит траектории в фазовом пространстве


Структура YAML конфигурации:

type: тип графика ('function' | 'ode_time' | 'phase_portrait')

curves: список кривых для построения
	Для type: function:
		- formula: LaTeX формула
		- params: локальные параметры (dict)
		- x_range: [x_min, x_max]
		- style: стиль линии (dict с параметрами matplotlib)

	Для type: ode_time:
		- equations: список LaTeX уравнений (правые части)
		- variable_names: имена переменных
		- initial_conditions: начальные условия
		- params: локальные параметры
		- t_span: [t_start, t_end]
		- styles: список стилей для каждой переменной

	Для type: phase_portrait:
		- equations: список LaTeX уравнений
		- variable_names: имена переменных
		- initial_conditions: начальные условия
		- params: локальные параметры
		- t_span: [t_start, t_end]
		- var_indices: [x_var_index, y_var_index]
		- style: стиль линии траектории

axes: настройки осей
	- xlim: [x_min, x_max] или null
	- ylim: [y_min, y_max] или null
	- xlabel: подпись оси x
	- ylabel: подпись оси y
	- grid: включить сетку (bool)
	- equal_aspect: одинаковый масштаб осей (bool)
	- spines: видимость границ (dict)
	- grid_style: стиль сетки (dict)
	- xticks: деления на оси x (list)
	- yticks: деления на оси y (list)

vector_field: настройки векторного поля (только для phase_portrait)
	- enabled: включить векторное поле (bool)
	- density: плотность сетки векторов (int)
	- color: цвет стрелок
	- alpha: прозрачность стрелок (float 0-1)
	- scale: масштаб стрелок (float)
	- width: толщина стрелок (float)

output: имя выходного SVG файла


Теперь несколько слов про некоторые файлы проекта:

I. "D:\graphic\test_simple.py"
 Строки 1-3:
	import sys
	import os
	sys.path.insert(0, os.path.dirname(os.path.abspath(__file__)))
Первая строка нужна для того, чтобы питон мог управлять путями импорта, вторая строка импортирует os, который позволяет работать с путями в windows, третью строчку разберем пошагово:
	1. __file__ - путь к test_simple.py
	2. os.path.abspath(__file__) - абсолютный путь (D:\graphic\test_simple.py)
	3. os.path.dirname(...) - директория (D:\graphic)
	4. sys.path.insert(0, ...) - добавляет D:\graphic в список путей поиска модулей
	5. sys.path - список директорий, где Python ищет модули при импорте
Это нужно для того, чтобы питон мог корректно находить модули core, utils. Лучше не задавать четкий путь, потому что проект может немного видоизменяться, а четкое указание путей усложняет добавление новых функций в проект.

II. params_global.py
Содержит глобальные параметры проекта:
	Физические параметры:
		- b, alpha, w0, s0, c, h - параметры моделируемой физической системы
	Параметры численного интегрирования:
		- t_max: максимальное время интегрирования
		- n_points: количество точек для построения графика
	ОДУ параметры:
		- t_span: временной интервал по умолчанию
		- rtol: относительная точность интегрирования
		- atol: абсолютная точность интегрирования
Эти параметры можно переопределить локально в YAML конфигурации через поле params.

III. Почему используется метод DOP853 для интегрирования ОДУ:
DOP853 - это метод Рунге-Кутты 8-го порядка точности с автоматическим контролем шага. Выбран потому что:
	1. Высокая точность - 8-й порядок обеспечивает минимальную ошибку
	2. Адаптивный шаг - автоматически уменьшает шаг там, где решение меняется быстро
	3. Хорошо подходит для жестких систем (stiff systems)
	4. Доступен в scipy.integrate.solve_ivp
Альтернативы (RK45, Radau, BDF) имеют меньший порядок точности или хуже работают с нежесткими системами.

IV. Почему используется sympy.lambdify:
lambdify преобразует символьное выражение sympy в быстро вычисляемую numpy функцию. Преимущества:
	1. Скорость - компилированная функция работает на порядки быстрее символьных вычислений
	2. Векторизация - автоматически работает с numpy массивами
	3. Гибкость - можно контролировать порядок аргументов функции
	4. Совместимость - результат совместим с scipy.integrate.solve_ivp
Альтернатива (прямая подстановка через subs) была бы в тысячи раз медленнее для массивов точек.


Запуск проекта:

Через командную строку:
	python main.py --config configs/example_function.yaml

Программно (test_simple.py, test_ode.py):
	1. Создать объект plotter (FunctionPlotter или ODEPlotter)
	2. Добавить кривые через соответствующие методы
	3. Настроить оси через set_axes
	4. Сохранить через save()

Результат сохраняется в директорию output/ в формате SVG.






Немного слов про компиляцию формул:
Формулы на самом деле легко писать для нашего проекта, достаточно написать формулу в виде кода латех. Формула латех превращается в SymPy дерево, за это в нашем коде отвечает строчка
	from sympy.parsing.latex import parse_latex
  	self.expr = parse_latex(formula_latex)
Что тут происходит: по формуле строится дерево следующего плана:
    Add
     /   \
    Pow   sin
   / \     |
  x   2    x
Дерево не обязательно бинарное. Для x + y + z будет построено дерево:
       +  
     / | \
    x  y  z

Плюс такого не совсем стандартного подхода заключается в том, что мы можем быстрее выполнять такие операции, как:
	1. 




Детальный разбор на примере

Строка:
  "x^2 + sin(x) + 5"

  Дерево:
          Add
         / |  \
       Pow sin 5
       / \  |
      x  2  x


Таблица сравнения действий 
  | Операция           | Строка                  | Дерево (уже построено) |
  |--------------------|-------------------------|------------------------|
  | Парсинг            | O(n) каждый раз         | O(n) один раз          |
  | Найти переменные   | O(n) + сложная логика   | O(узлов)               |
  | Дифференцирование  | O(n парсинг) + O(узлов) | O(узлов)               |
  | Подстановка        | O(n) eval (опасно!)     | O(узлов)               |
  | Упрощение          | Невозможно              | O(узлов)               |
  | Компиляция в numpy | Невозможно              | O(узлов)               |



После создания дерева, перед вычислением формулы, мы преобразуем дерево в векторизованную функцию. Векторизованная функция - это функция, которая принимает массив и возвращает тоже массив, обрабатывая все элементы одновременно. Это все дело написано на C/Fortran, поэтому так быстро и работает.Получается значение функции на большом количестве переменных вычисляется за раз, а не за несколько раз, то есть массив из 1000 переменных выичслияется реально за раз, а не как в питон коде за 1000 отдельныхопераций. 
Если не превращать дерево в векторизованную функцию, то для вычисления значения функции придется обходить все дерево. Помимо этого у векторизованной функции есть плюс в быстроте выполнения, а именно использование SIMD - Single Instruction, Multiple Data. Это технология, которая позволяет одной командой обрабатывать несколько чисел одновременно. 

 Как это работает физически?

  Обычный регистр CPU (64 бита):

  ┌────────────┐
  │     5      │  Одно число
  └────────────┘

  SIMD регистр (256 бит AVX):

  ┌─────┬─────┬─────┬─────┐
  │   1   │  2    │  3   │  4    │  Четыре числа!
  └─────┴─────┴─────┴─────┘

  Одна инструкция обрабатывает весь регистр (все 4 числа сразу).

На моем процессоре Core i9 12900h работает AVX2 - 256бит, 8 чисел одновременно. Немного инфы. Есть Процессоры на 512бит, которые обрабатывают по 16 чисел за раз. Получается нахаляву мы ускоряем прогу в 8 раз. 


Что мы используем для ускорения программы:
1. Строим по формуле латех дерево. Дерево хранится в памяти линейно
2. Делаем векторизованную функцию. 
3. Кэширование дерева формул. Оно позволяет обращаться к дереву, в котором хранится наша формула, всего один раз - в самом начале. 
4. SIMD операции через nympy - ускоряет до 8 раз нашу программу, сильно зависит от функции и количества данных.


Для ввода данных используется файл с расширением .yaml, а не привычные .txt файлы, потому что:
	1. Файлы .yaml поддерживают иерархию: файл понимает отсупыты, что позволяет проще задавать данные
	2. Файл

Файл global_params.py нужен для глобального задания параметров. Этот файл можно было и не делать, но с ним просто удобнее. 



При сохранении файла библиотека Matplotlib не сохраняет все точки в формат SVG, а сохраняет только "отличающиеся" точки, то если есть 5 точек, лежашие почти на одной прямой, то он 
сохранит только 3 точки. Это оптимизирует размер файла.





ч


Про входные данные и как их вбивать в конфигурационный файл .yaml:
В самом начале указываем тип графика:  type: 
	1. function - обычный график f от x
	2. ode_time - решение ОДУ, который зависит от времени 
	3. phase_portrait - построение фазового потрета
После указания типа графика указываем сами кривые, которые должны быть на одном графике. 
Для указания элементов в конфигурационном файле расширения .yaml надо писать "-" перед элементом. 
После чего пишем само уравнение. Например: equations: ["-s * \\exp(-w)", "c * (1 - w - b * \\exp(h * s) * (1 + w))"]
Преимущество нашей программы в том, что уравнения мы задаем в привычном нам латех коде, только с одним нюансом, обратный слеш пишется двойным, потому что в питон есть много команд с одинарным 
слэшом и сделали библиотеку спецаильно с двойным, чтобы не было проблем. 
После чего указываем variable_names - это исходные переменные, не параметры. Строчкой ниже задаем их начальные значения.
Ниже пишем params: {c: 0.3, b: 1.0e-12, h: 0.07} - это какие параметры есть в уравнении и чему они равны.
t_span: [0, 6] - интервал времени для решения ОДУ. От чего до чего меняется время t в нашей ОДУ

Объясним для чего нужна следующая строчка:
styles:
      - {color: "blue", linestyle: "-", linewidth: 1.5, label: "s, w₀=0.02"}
      - {color: "blue", linestyle: "--", linewidth: 1.5, label: "w, w₀=0.02"}
Это задание визуального эффекта наших кривых. Из неочевидных:
	1. linestyle:
		"-"   сплошная линия
		"--"  пунктир
		"-."  штрих-пунктир 
		":"   точечная линия
	2. label - это штука справа сверху, но она не нужна как оказалась
С тем, как вводить ОДУ разобрались. Дальше поговорим про то, как настраивать оси 










ДОбавить автоматическое подтягивание параметров для label, если они указываются
ПОправить файл чтобы строилось все нормально 
Построить примеры других МФ(степенные)
ОДну g брать линейную, 


слайд 1 - исходные уравнения
слайд 2 - уравнения упрощзенные для олучения КР
слайд 3 - сравнение КР, которые мы получили и в статье. Слева и справа
слайд 4 - КР при тех же параметрах, но с заменой материальной функции. МОжно вынести уравнение, например. 
слайд 5 - свободное творчество. Можно поменять чисто \alpha. Если альфа сделать большим, то кривые начнут пересекаться. Можно поменять параметры. Нельзя брать отрицательными.
Можно посмотреть, как влияет c or b. 


Когда начнем делать численные решения для диаграмм деформирования, заметим, что если скорость сделать равной 0, то получим уравнения, которые уже делали. 



потом показываем готовые слайды 


















